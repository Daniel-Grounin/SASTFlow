package com.sast;

import java.util.*;
import java.util.regex.*;

public class VulnerabilityChecker {
    public static List<String> checkVulnerabilities(String fileContent) {
        List<String> report = new ArrayList<>();
        if (fileContent.contains("password") && fileContent.contains("=")) {
            report.add("Hardcoded Password Found: Avoid storing passwords in source code.");
        }
        if (fileContent.contains("executeQuery(") && fileContent.contains("createStatement()")) {
            report.add("SQL Injection Risk: Uses Statement.executeQuery() without PreparedStatement.");
        }
        if (fileContent.contains("new File(") && (fileContent.contains("/etc/") || fileContent.contains("C:\\\\"))) {
            report.add("Insecure File Handling: Direct access to system files.");
        }


        // âš  SQL Injection Detection (Unsafe Statement execution)
        Pattern sqlPattern = Pattern.compile("Statement\\s+.*executeQuery\\(");
        Matcher sqlMatcher = sqlPattern.matcher(fileContent);
        while (sqlMatcher.find()) {
            report.add("SQL Injection Risk at line " + getLineNumber(fileContent, sqlMatcher.start()) +
                    ": Uses Statement.executeQuery() without PreparedStatement.");
        }

        // âš  Hardcoded Credentials Detection (Detect "password =")
        Pattern passwordPattern = Pattern.compile("password\\s*=\\s*\".*\"");
        Matcher passwordMatcher = passwordPattern.matcher(fileContent);
        while (passwordMatcher.find()) {
            report.add("Hardcoded Password Found at line " + getLineNumber(fileContent, passwordMatcher.start()) +
                    ": Avoid storing passwords in source code.");
        }

        // âš  Insecure File Handling Detection
        Pattern filePattern = Pattern.compile("new\\s+FileReader\\(");
        Matcher fileMatcher = filePattern.matcher(fileContent);
        while (fileMatcher.find()) {
            report.add("Insecure File Handling at line " + getLineNumber(fileContent, fileMatcher.start()) +
                    ": Avoid allowing arbitrary file read.");
        }

        // âš  Command Injection Detection (Runtime exec)
        Pattern commandExecPattern = Pattern.compile("Runtime\\.getRuntime\\(\\)\\.exec\\(");
        Matcher commandExecMatcher = commandExecPattern.matcher(fileContent);
        while (commandExecMatcher.find()) {
            report.add("Command Injection Risk at line " + getLineNumber(fileContent, commandExecMatcher.start()) +
                    ": Unvalidated input can allow arbitrary command execution.");
        }

        // âš  Weak Encryption Detection (Base64 encoding passwords)
        Pattern base64Pattern = Pattern.compile("Base64\\.getEncoder\\(\\)\\.encodeToString\\(");
        Matcher base64Matcher = base64Pattern.matcher(fileContent);
        while (base64Matcher.find()) {
            report.add("Weak Encryption at line " + getLineNumber(fileContent, base64Matcher.start()) +
                    ": Base64 encoding is NOT secure. Use proper hashing (e.g., BCrypt, Argon2).");
        }

        // âš  Cross-Site Scripting (XSS) Detection (Printing user input)
        Pattern xssPattern = Pattern.compile("System\\.out\\.println\\(.*scanner\\.nextLine");
        Matcher xssMatcher = xssPattern.matcher(fileContent);
        while (xssMatcher.find()) {
            report.add("Potential XSS Vulnerability at line " + getLineNumber(fileContent, xssMatcher.start()) +
                    ": Printing unsanitized user input.");
        }

        // âš  Unrestricted Deserialization Detection
        Pattern deserializationPattern = Pattern.compile("new\\s+ObjectInputStream\\(");
        Matcher deserializationMatcher = deserializationPattern.matcher(fileContent);
        while (deserializationMatcher.find()) {
            report.add("Unrestricted Deserialization at line " + getLineNumber(fileContent, deserializationMatcher.start()) +
                    ": Can lead to remote code execution.");
        }

        // âš  JavaScript Execution via `ScriptEngine`
        Pattern jsPattern = Pattern.compile("engine\\.eval\\(");
        Matcher jsMatcher = jsPattern.matcher(fileContent);
        while (jsMatcher.find()) {
            report.add("Arbitrary JavaScript Execution at line " + getLineNumber(fileContent, jsMatcher.start()) +
                    ": Running user-supplied JS code is dangerous.");
        }

        return report;
    }

    // ðŸ”¹ Helper function to get line number from character position
    private static int getLineNumber(String fileContent, int charPosition) {
        return fileContent.substring(0, charPosition).split("\n").length;
    }
}
